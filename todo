SLL-Meta-Approach for generating names


Generating residual program. Options - free vars. No free vars. ETC.

Applications:

1. "Minimal" programs (search the most descriptive and concise variant of the given program).
2. Transformations with lemmas/theorems.
3. Different approximation - as in Klimov paper.
4. Implement call-by-name (reference implementation), call-by-value and call-by-need.



Experiment configuration:
1)   whistle
2) 	 how to fold -> in path only or also in all completed nodes
3) 	 just count or generate results??
4) 	 speculation - yes/no
5) 	 how to generalize -? always or only on whistle??
5.a) it is possible to find only superConfigurations with respect to e1, e2
6) lemmas
7) replace/forest on generalization
8) global/local control
9) (maximal) free expression extraction - reducing number of argument of function




TODO: find the case where e1 < e2 but msg = e2. Can it be done by just driving??

TODO: we can blame all expressions

-----

replace/rollback - how to be with info??? Seems that we need two kinds of info, but I am not sure.
The current hack: copy/not copy it.

for now there is a hack of passing blamed node in p SLL machine

we need to pass blamed node into subsequent calls

TODO: ticks

---

TODO: there may be many drive case - propagate/not propagate extra also
---
Why do we have this??
let f.4() = Nil() in f.4();

--- 
We have potentially big issue with "MComplete"/stop step command - this command should not be "pending" one
since it causes hacks in folding and hacks in driving.


So known non-elegancies: generalization of non-coupled expressions.

TODO: strategy for when msg fails.

make it close to fold-unfold frameworks. - Allow to make "eurekas". 

Look into generic abstract machines: see "abstracting abstract machines"

for rev test: allow to fold every where-just to calculate number of trees


TODO:_______

самый большой граф - самый короткий...
поиск лучшего по критерию

ordering of let-expressions - just for enumerating

need more effective filtering/whistles combinations -> hard prune??

hints for rebuildings

graph serialization/de-serialization

--------------

app xs ys = app' xs ys []

app' (x:xs) ys acc = app' xs ys (x:acc);
app' [] ys acc = app'' ys acc;

app'' (y:ys) acc = app ys (y:acc);
app'' [] acc = rev acc [];

------------

Task: transform non-flat program into a flat program.